# Learning Log: FastAPI, Uvicorn, and UV

## Table of Contents
1. [What is FastAPI?](#what-is-fastapi)
2. [What is Uvicorn?](#what-is-uvicorn)
3. [The Relationship Between FastAPI and Uvicorn](#the-relationship)
4. [What is UV?](#what-is-uv)
5. [Installing FastAPI and Uvicorn with UV](#installing-with-uv)
6. [Practical Examples](#practical-examples)

---

## What is FastAPI?

### Definition
**FastAPI** is a modern Python web framework for building APIs (Application Programming Interfaces).

### Think of it Like This:
```
Your Code (FastAPI) = A Restaurant Menu
- You define what dishes (endpoints) are available
- You specify what ingredients (parameters) each dish needs
- You describe what the dish looks like (return types)

Example:
@app.get("/health")  ← This is like "Menu Item: Health Check"
def health():         ← This is the recipe
    return {"ok": True}  ← This is what the customer gets
```

### What FastAPI Actually Does:

1. **Defines Routes (URLs)**
   ```python
   @app.get("/health")      # GET request to /health
   @app.post("/users")      # POST request to /users
   @app.websocket("/ws")    # WebSocket connection
   ```

2. **Handles Requests**
   - Receives HTTP requests from browsers/apps
   - Parses the data (JSON, forms, files)
   - Validates the input automatically

3. **Returns Responses**
   - Converts Python objects to JSON
   - Sets proper HTTP status codes
   - Handles errors gracefully

4. **Generates Documentation**
   - Automatically creates API docs at `/docs`
   - Interactive interface to test your API
   - Based on your Python type hints

### Key Features:

- **Fast**: One of the fastest Python frameworks (comparable to NodeJS/Go)
- **Type Hints**: Uses Python type annotations for validation
- **Async Support**: Built on ASGI (Asynchronous Server Gateway Interface)
- **Auto Documentation**: Swagger UI and ReDoc built-in
- **Data Validation**: Uses Pydantic for automatic validation

### Example:
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/health")
def health():
    return {"ok": True}
```

**What happens:**
1. Browser requests: `GET http://localhost:8000/health`
2. FastAPI sees the route matches `/health`
3. FastAPI calls your `health()` function
4. FastAPI converts `{"ok": True}` to JSON
5. Browser receives: `{"ok":true}`

---

## What is Uvicorn?

### Definition
**Uvicorn** is an ASGI (Asynchronous Server Gateway Interface) web server. It's the program that actually runs your FastAPI application and listens for incoming network connections.

### The Problem Uvicorn Solves:

Your FastAPI code is just Python functions. It cannot:
- Open network ports
- Listen for HTTP requests
- Handle multiple connections simultaneously
- Understand the HTTP protocol
- Send responses back over the network

**Uvicorn does all of this!**

### Think of it Like This:
```
FastAPI = Chef (knows how to cook)
Uvicorn = Restaurant Building (provides kitchen, tables, takes orders)

Without Uvicorn:
- Chef has recipes but nowhere to cook
- No customers can reach the chef
- Food just sits there

With Uvicorn:
- Opens the restaurant (port 8000)
- Takes customer orders (HTTP requests)
- Delivers orders to chef (calls FastAPI)
- Serves the food to customers (sends responses)
```

### What Uvicorn Actually Does:

1. **Opens a Network Port**
   ```bash
   uvicorn main:app --port 8000
   ```
   - Binds to port 8000
   - Listens for TCP connections
   **What is TCP ?**
      *Transmission Control Protocol (TCP) is a fundamental communication protocol used in computer networks, including the internet. It is responsible for establishing a reliable connection between two devices (such as a client and a server) and ensuring that data is transmitted accurately and in the correct order.*
   - Waits for HTTP requests
   **What is HTTP ?**
      *Hypertext Transfer Protocol (HTTP) is the foundational protocol used for transmitting data on the World Wide Web. It defines how messages are formatted and transmitted, and how web servers and browsers should respond to various commands.* 
   **What is a Port ?**
      *A port is a numerical identifier in computer networking that helps direct data to the correct application or service on a device. It acts as a communication endpoint for network connections, allowing multiple services to run simultaneously on a single IP address by using different port numbers.*
   **What is the difference between TCP and HTTP ?**
      *TCP (Transmission Control Protocol) is a low-level protocol that establishes a reliable connection between two devices for data transmission. It ensures that data packets are delivered accurately and in the correct order. HTTP (Hypertext Transfer Protocol), on the other hand, is a higher-level protocol built on top of TCP. It defines how messages are formatted and transmitted for web communication, such as loading web pages and sending form data.* 

2. **Handles the HTTP Protocol**
   - Parses incoming HTTP requests (GET, POST, etc.)
   - Reads headers, body, query parameters
   - Formats responses with proper HTTP structure

3. **Manages Connections**
   - Handles multiple clients simultaneously
   - Uses async I/O for efficiency
   - Manages keep-alive connections

4. **Communicates with FastAPI**
   - Passes requests to your FastAPI application
   - Receives responses from your code
   - Sends responses back to clients

### ASGI Explained:

**ASGI** (Asynchronous Server Gateway Interface) is a standard protocol for communication between web servers and Python web applications.

```
Client (Browser) ←→ Uvicorn (ASGI Server) ←→ FastAPI (ASGI App)
                      ↑
                   Speaks HTTP
                      ↓
                   Speaks ASGI
```

### Why "Asynchronous"?

Traditional servers (like Gunicorn/WSGI) handle one request per worker:
```
Request 1 → Worker 1 (blocked until complete)
Request 2 → Worker 2 (blocked until complete)
Request 3 → Worker 3 (blocked until complete)
```

ASGI servers (like Uvicorn) can handle multiple requests with one worker:
```
Worker 1:
  Request 1 (waiting for database) → paused
  Request 2 (waiting for API call) → paused
  Request 3 (quick response) → completed
  Request 1 (database returned) → completed
  Request 2 (API returned) → completed
```

### Uvicorn Command Breakdown:

```bash
uvicorn main:app --reload --host 0.0.0.0 --port 8000
│       │   │    │         │             │
│       │   │    │         │             └─ Port number
│       │   │    │         └─ Listen on all network interfaces
│       │   │    └─ Auto-restart when code changes
│       │   └─ The FastAPI app object
│       └─ The Python file (main.py)
└─ The Uvicorn command
```

**What each part means:**

- `main:app` → Import `app` from `main.py`
- `--reload` → Watch for file changes and restart automatically (dev mode only!)
- `--host 0.0.0.0` → Accept connections from any IP (not just localhost)
- `--port 8000` → Listen on port 8000

### Alternatives to Uvicorn:

- **Hypercorn**: Another ASGI server, supports HTTP/2
- **Daphne**: ASGI server by Django team
- **Gunicorn**: WSGI server (not for FastAPI, for Flask/Django)

Uvicorn is the **most popular** for FastAPI because it's the fastest and most reliable.

---

## The Relationship Between FastAPI and Uvicorn

### The Complete Picture:

```
┌─────────────────────────────────────────────────┐
│  Browser/Client                                 │
│  "GET http://192.168.0.100:8000/health"        │
└────────────────┬────────────────────────────────┘
                 │ HTTP Request over network
                 ↓
┌─────────────────────────────────────────────────┐
│  Uvicorn (Web Server)                           │
│  - Opens port 8000                              │
│  - Receives HTTP request                        │
│  - Parses: GET /health                          │
└────────────────┬────────────────────────────────┘
                 │ ASGI Protocol
                 ↓
┌─────────────────────────────────────────────────┐
│  FastAPI (Web Framework)                        │
│  - Matches route: @app.get("/health")          │
│  - Calls function: health()                     │
│  - Returns: {"ok": True}                        │
└────────────────┬────────────────────────────────┘
                 │ ASGI Protocol
                 ↓
┌─────────────────────────────────────────────────┐
│  Uvicorn                                        │
│  - Converts to HTTP response                    │
│  - Sends: HTTP/1.1 200 OK                       │
│           Content-Type: application/json        │
│           {"ok":true}                           │
└────────────────┬────────────────────────────────┘
                 │ HTTP Response over network
                 ↓
┌─────────────────────────────────────────────────┐
│  Browser/Client                                 │
│  Displays: {"ok":true}                          │
└─────────────────────────────────────────────────┘
```

### Why You Need Both:

**FastAPI alone:**
```python
from fastapi import FastAPI
app = FastAPI()

@app.get("/health")
def health():
    return {"ok": True}
```
❌ This code does **nothing** by itself
❌ No server is running
❌ No port is open
❌ No one can access it

**With Uvicorn:**
```bash
uvicorn main:app --host 0.0.0.0 --port 8000
```
✅ Uvicorn starts
✅ Port 8000 opens
✅ Server waits for requests
✅ Your FastAPI app is accessible

### Real-World Analogy:

```
FastAPI = Microsoft Word (the application)
Uvicorn = Windows/macOS (the operating system that runs it)

You can't use Word without an OS to run it.
You can't use FastAPI without a server to run it.
```

---

## What is UV?

### Definition
**UV** is a modern, extremely fast Python package manager and project manager written in Rust. It's a replacement for pip, virtualenv, poetry, and other Python tools.

### The Problem UV Solves:

Traditional Python workflow is complex:
```bash
# Old way:
python -m venv venv              # Create virtual environment
source venv/bin/activate         # Activate it
pip install fastapi uvicorn      # Install packages
python -m uvicorn main:app       # Run the app

# Multiple tools:
- venv (virtual environments)
- pip (package installer)
- Manual activation
- Slow installation
```

UV simplifies this:
```bash
# New way with UV:
uv run uvicorn main:app          # That's it!

# UV automatically:
- Creates virtual environment
- Reads pyproject.toml
- Installs dependencies
- Runs your command
- 10-100x faster than pip
```

### What UV Actually Is:

UV is **multiple tools in one**:

1. **Package Installer** (replaces pip)
   ```bash
   uv pip install fastapi
   ```

2. **Virtual Environment Manager** (replaces venv/virtualenv)
   ```bash
   uv venv
   ```

3. **Project Manager** (replaces poetry/pipenv)
   ```bash
   uv init
   uv add fastapi
   ```

4. **Command Runner** (runs commands in isolated environments)
   ```bash
   uv run python script.py
   uv run uvicorn main:app
   ```

### Key Features:

#### 1. **Speed**
- Written in Rust (compiled, not interpreted)
- Parallel downloads
- Caches everything
- 10-100x faster than pip

```
pip install:    45 seconds
uv pip install: 2 seconds
```

#### 2. **Automatic Environment Management**
```bash
# Traditional:
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
python main.py

# With UV:
uv run python main.py  # Handles everything automatically
```

#### 3. **Reads pyproject.toml**
Your `pyproject.toml`:
```toml
[project]
name = "backend"
dependencies = [
    "fastapi>=0.128.0",
    "uvicorn[standard]>=0.40.0",
]
```

When you run `uv run uvicorn main:app`:
- UV reads `pyproject.toml`
- Creates `.venv/` automatically
- Installs fastapi and uvicorn
- Runs your command

#### 4. **Cross-Platform**
Works identically on:
- Linux
- macOS
- Windows

No more "source venv/bin/activate" vs "venv\Scripts\activate.bat"

### UV vs Other Tools:

| Tool | UV Equivalent | Speed | Features |
|------|---------------|-------|----------|
| pip | `uv pip` | 100x faster | Same + better |
| venv | `uv venv` | Instant | Same + automatic |
| poetry | `uv` | 10x faster | Same + simpler |
| pipx | `uv tool` | 100x faster | Same + better |

### How UV Works Internally:

```
┌─────────────────────────────────────────────────┐
│  uv run uvicorn main:app                        │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│  1. Check for .venv directory                   │
│     Not found → Create .venv                    │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│  2. Read pyproject.toml                         │
│     Found: fastapi>=0.128.0                     │
│            uvicorn[standard]>=0.40.0            │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│  3. Check if packages are installed             │
│     Not found → Install from PyPI               │
│     - Download wheels (parallel)                │
│     - Cache in ~/.cache/uv                      │
│     - Install to .venv                          │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│  4. Activate .venv (internally)                 │
│     Set PATH to .venv/bin                       │
└────────────────┬────────────────────────────────┘
                 ↓
┌─────────────────────────────────────────────────┐
│  5. Run command: uvicorn main:app               │
│     Execute .venv/bin/uvicorn                   │
└─────────────────────────────────────────────────┘
```

### Why UV is Revolutionary:

**Before UV:**
```bash
# Project setup (complex, slow)
python3 -m venv venv
source venv/bin/activate          # Different on Windows!
pip install --upgrade pip          # Need to upgrade pip first
pip install -r requirements.txt   # Slow, sequential
pip freeze > requirements.txt     # Manual dependency tracking
```

**With UV:**
```bash
# Project setup (simple, fast)
uv run uvicorn main:app           # Done!
```

UV handles:
- ✅ Virtual environment creation
- ✅ Dependency resolution
- ✅ Package installation
- ✅ Cache management
- ✅ Cross-platform compatibility
- ✅ Parallel downloads
- ✅ Lock files

---

## Installing FastAPI and Uvicorn with UV

### Method 1: Using pyproject.toml (Recommended)

**Step 1: Create pyproject.toml**
```toml
[project]
name = "backend"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
    "fastapi>=0.128.0",
    "uvicorn[standard]>=0.40.0",
]
```

**Step 2: Run your app**
```bash
uv run uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

**What happens:**
1. UV reads `pyproject.toml`
2. Creates `.venv/` if it doesn't exist
3. Installs `fastapi` and `uvicorn` with all dependencies
4. Runs uvicorn with your app

### Method 2: Direct Installation

```bash
# Create virtual environment
uv venv

# Install packages
uv pip install fastapi uvicorn[standard]

# Run app
uv run uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

### Method 3: One-Time Script Execution

```bash
# Run without creating a persistent environment
uvx uvicorn main:app --reload
```

### Understanding the Installation:

When you run `uv pip install fastapi uvicorn[standard]`:

1. **FastAPI Installation:**
   ```
   fastapi
   ├── pydantic (data validation)
   ├── starlette (ASGI framework)
   ├── typing-extensions (type hints)
   └── ... other dependencies
   ```

2. **Uvicorn Installation:**
   ```
   uvicorn[standard]
   ├── uvicorn (core server)
   ├── websockets (WebSocket support)
   ├── httptools (fast HTTP parsing)
   ├── uvloop (faster event loop)
   └── ... other dependencies
   ```

The `[standard]` means "install with all recommended features"

### Verification:

```bash
# Check installed packages
uv pip list

# Should see:
# fastapi        0.128.0
# uvicorn        0.40.0
# ... and their dependencies
```

---

## Practical Examples

### Example 1: Basic Setup

**Directory structure:**
```
classroom-pong/
├── backend/
│   ├── main.py
│   └── pyproject.toml
└── frontend/
```

**backend/pyproject.toml:**
```toml
[project]
name = "backend"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
    "fastapi>=0.128.0",
    "uvicorn[standard]>=0.40.0",
]
```

**backend/main.py:**
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/health")
def health():
    return {"ok": True}
```

**Run it:**
```bash
cd backend
uv run uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

**Test it:**
```bash
curl http://localhost:8000/health
# Output: {"ok":true}
```

### Example 2: With WebSocket Support

**backend/main.py:**
```python
from fastapi import FastAPI, WebSocket

app = FastAPI()

@app.get("/health")
def health():
    return {"ok": True}

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Echo: {data}")
```

**Run it:**
```bash
uv run uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

Now you have:
- HTTP endpoint: `http://localhost:8000/health`
- WebSocket endpoint: `ws://localhost:8000/ws`

### Example 3: Production vs Development

**Development:**
```bash
uv run uvicorn main:app --reload --host 0.0.0.0 --port 8000
# --reload: Auto-restart on code changes (uses more resources)
```

**Production:**
```bash
uv run uvicorn main:app --host 0.0.0.0 --port 8000 --workers 4
# --workers 4: Run 4 worker processes for better performance
# No --reload: Stable, production-ready
```

---

## Summary

### FastAPI:
- **What**: Python web framework for building APIs
- **Does**: Defines routes, handles requests, validates data, returns responses
- **Think**: The chef who knows the recipes

### Uvicorn:
- **What**: ASGI web server
- **Does**: Opens ports, listens for connections, runs your FastAPI app
- **Think**: The restaurant building that serves customers

### UV:
- **What**: Fast Python package manager (written in Rust)
- **Does**: Manages environments, installs packages, runs commands
- **Think**: The automated assistant that handles all the setup

### The Complete Flow:
```
UV → Installs → FastAPI + Uvicorn
                    ↓
Uvicorn → Runs → FastAPI app
                    ↓
FastAPI → Handles → HTTP/WebSocket requests
                    ↓
Browser ← Receives ← JSON responses
```

### One-Command Magic:
```bash
uv run uvicorn main:app --reload --host 0.0.0.0 --port 8000
```

This single command:
1. UV creates virtual environment
2. UV installs FastAPI and Uvicorn
3. Uvicorn starts the server
4. FastAPI handles your routes
5. Your app is live on the network!

---

**Date Created:** 1 February 2026  
**Project:** classroom-pong  
**Author:** Learning session with GitHub Copilot
