# SQLAlchemy + FastAPI - Notes d'apprentissage

## SQLAlchemy ORM

### Les 3 éléments fondamentaux

Toute application SQLAlchemy repose sur ces trois composants :

| Composant | Rôle | Analogie |
|-----------|------|----------|
| **Engine** | Gère la connexion et le pool de connexions | Le "pilote" qui parle à la DB |
| **Session** | Gère les transactions et le suivi des objets | Un "espace de travail" |
| **Base** | Classe parent pour tous les modèles ORM | La "fabrique" de tables |

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

engine = create_engine("sqlite:///./database.db")
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()
```

### Définir un modèle

Un modèle = une table. Chaque attribut = une colonne.

```python
from sqlalchemy import Column, Integer, String

class Author(Base):
    __tablename__ = "authors"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
```

### Relations entre tables

#### ForeignKey vs relationship()

| Élément | Où il existe | Ce qu'il fait |
|---------|--------------|---------------|
| `ForeignKey` | Dans la base de données | Crée une contrainte de clé étrangère |
| `relationship()` | Uniquement en Python | Permet la navigation entre objets |

#### Exemple : One-to-Many

```python
class Author(Base):
    __tablename__ = "authors"
    id = Column(Integer, primary_key=True)
    name = Column(String(100))
    books = relationship("Book", back_populates="author")  # Liste de livres

class Book(Base):
    __tablename__ = "books"
    id = Column(Integer, primary_key=True)
    title = Column(String(200))
    author_id = Column(Integer, ForeignKey("authors.id"))  # Clé étrangère
    author = relationship("Author", back_populates="books")  # Un seul auteur
```

Utilisation :
```python
# Naviguer dans les deux sens
print(author.books)      # → [<Book ...>, <Book ...>]
print(book.author.name)  # → "Victor Hugo"
```

`back_populates` synchronise les deux côtés automatiquement.

### Flush vs Commit

| Opération | Ce qu'elle fait |
|-----------|-----------------|
| **Flush** | Envoie les INSERT/UPDATE/DELETE à la DB, mais la transaction reste ouverte |
| **Commit** | Flush + sauvegarde permanente de la transaction |

```python
session.add(new_book)   # En mémoire seulement
session.flush()         # Envoyé à la DB, mais peut être annulé
session.commit()        # Permanent
```

### Context Manager pour les sessions

Le context manager garantit que `db.close()` s'exécute toujours, même en cas d'erreur.

```python
from contextlib import contextmanager

@contextmanager
def get_db():
    db = SessionLocal()
    try:
        yield db       # 1. Pause, donne db au code appelant
    finally:
        db.close()     # 2. S'exécute TOUJOURS après

# Utilisation
with get_db() as db:
    db.add(author)
    db.commit()
# db.close() appelé automatiquement
```

#### Le mot-clé `yield`

`yield` est comme `return`, mais la fonction **pause** au lieu de terminer. Elle reprend après que le code appelant a fini.

---

## FastAPI

### Structure de base

```python
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session

app = FastAPI()

@app.get("/items")
def read_items(db: Session = Depends(get_db)):
    return db.query(Item).all()

@app.post("/items")
def create_item(item: ItemCreate, db: Session = Depends(get_db)):
    db_item = Item(**item.dict())
    db.add(db_item)
    db.commit()
    return db_item
```

### Depends() - Injection de dépendances

`Depends(get_db)` injecte automatiquement une session de base de données dans chaque requête.

```python
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/authors")
def read_authors(db: Session = Depends(get_db)):
    # db est injecté automatiquement par FastAPI
    return db.query(Author).all()
```

### Documentation automatique avec /docs

FastAPI génère automatiquement une documentation interactive.

#### Accès
```
http://localhost:8000/docs     # Swagger UI (interactif)
http://localhost:8000/redoc    # ReDoc (lecture)
```

#### Ce que /docs permet
- Voir tous les endpoints disponibles
- Tester les requêtes directement dans le navigateur
- Voir les schémas de données attendus
- Voir les réponses possibles (200, 404, 422...)

#### Comment ça marche
FastAPI utilise les **type hints** et les **schémas Pydantic** pour générer la documentation :

```python
@app.post("/authors", response_model=AuthorResponse)
def create_author(author: AuthorCreate):
    #              ↑                    ↑
    #              Documenté comme      Documenté comme
    #              "Request Body"       "Response"
```

---

## Pydantic

### Pourquoi Pydantic ?

| Sans Pydantic | Avec Pydantic |
|---------------|---------------|
| Validation manuelle | Validation automatique |
| Pas de documentation | Documentation auto-générée |
| Erreurs peu claires | Messages d'erreur précis |

### Schémas de base

```python
from pydantic import BaseModel

class AuthorCreate(BaseModel):   # Pour créer (pas d'id)
    name: str

class AuthorResponse(BaseModel):  # Pour retourner (avec id)
    id: int
    name: str

    class Config:
        from_attributes = True  # Permet conversion depuis SQLAlchemy
```

### Flux des données

```
Client envoie JSON → Pydantic valide → SQLAlchemy sauve → DB
DB → SQLAlchemy lit → Pydantic formate → Client reçoit JSON
```

### Validation automatique

Si les données sont invalides, FastAPI retourne automatiquement une erreur 422 :

```json
// Requête: POST /authors {"name": 123}
// Réponse: 422 Unprocessable Entity
{
  "detail": [{
    "loc": ["body", "name"],
    "msg": "Input should be a valid string",
    "type": "string_type"
  }]
}
```

### Contraintes de validation

```python
from pydantic import BaseModel, Field

class AuthorCreate(BaseModel):
    name: str = Field(min_length=1, max_length=100)
```

---

## Gestion des erreurs

### Erreurs automatiques (Pydantic)

| Code | Quand |
|------|-------|
| 422 | Données invalides (mauvais type, champ manquant) |

### Erreurs manuelles (HTTPException)

```python
from fastapi import HTTPException

@app.get("/authors/{author_id}")
def read_author(author_id: int, db: Session = Depends(get_db)):
    author = db.query(Author).filter(Author.id == author_id).first()
    if not author:
        raise HTTPException(status_code=404, detail="Author not found")
    return author
```

| Code | Usage typique |
|------|---------------|
| 400 | Requête invalide (logique métier) |
| 404 | Ressource non trouvée |
| 403 | Accès interdit |
| 409 | Conflit (doublon) |

---

## Architecture typique d'un projet

```
project/
├── database.py    # Connexion DB (engine, session, base)
├── models.py      # Modèles SQLAlchemy (tables)
├── schemas.py     # Modèles Pydantic (validation API)
├── app.py         # Routes FastAPI (endpoints)
└── main.py        # Point d'entrée ou scripts
```

| Fichier | Responsabilité |
|---------|----------------|
| `database.py` | Configuration de la connexion |
| `models.py` | Structure des tables (ce qui est stocké) |
| `schemas.py` | Structure de l'API (ce qui entre/sort) |
| `app.py` | Logique des routes HTTP |

---

## Commandes utiles

```bash
# Lancer le serveur de développement
uvicorn app:app --reload

# Avec uv
uv run uvicorn app:app --reload

# Accéder à la documentation
# http://localhost:8000/docs
```

---

## Résumé visuel

```
┌─────────────┐     HTTP Request      ┌─────────────┐
│   Client    │ ───────────────────── │   FastAPI   │
│  (Frontend) │     POST /authors     │             │
└─────────────┘     {"name": "..."}   └──────┬──────┘
                                             │
                                    ┌────────▼────────┐
                                    │    Pydantic     │
                                    │   (validation)  │
                                    └────────┬────────┘
                                             │
                                    ┌────────▼────────┐
                                    │   SQLAlchemy    │
                                    │   (ORM/Session) │
                                    └────────┬────────┘
                                             │
                                    ┌────────▼────────┐
                                    │    Database     │
                                    │    (SQLite)     │
                                    └─────────────────┘
```
