# Learning Log : requestAnimationFrame (RAF)

**Date :** 25 janvier 2026  
**Contexte :** Animation du cercle trigonométrique en React + JSXGraph

---

## Ce que j'ai appris

### `requestAnimationFrame` est une API native du navigateur

- **Pas spécifique à React, ni à JSXGraph, ni à aucune librairie**
- C'est du JavaScript pur fourni par tous les navigateurs modernes
- Créé par le W3C, supporté depuis ~2012

### À quoi ça sert

`requestAnimationFrame` (RAF) permet de créer des **animations fluides** synchronisées avec le refresh de l'écran.
```javascript
requestAnimationFrame(callback)
```

Le navigateur appelle `callback` **juste avant le prochain repaint de l'écran** (généralement 60 fois/seconde).

---

## Comment ça fonctionne

### Pattern de base
```javascript
function animate(timestamp) {
  // Fait quelque chose (ex: bouge un élément)
  console.log("Frame!", timestamp)
  
  // Demande au navigateur de rappeler animate() à la prochaine frame
  requestAnimationFrame(animate)
}

// Lance la première frame
requestAnimationFrame(animate)
```

**Résultat :** `animate()` est appelé ~60 fois par seconde (si écran 60Hz)

### C'est une récursion asynchrone

- La fonction `animate()` s'appelle elle-même
- **MAIS** chaque appel se termine avant le suivant (pas d'empilement)
- Pas de stack overflow car c'est asynchrone
```
animate() termine
  ↓ (16ms plus tard)
animate() termine
  ↓ (16ms plus tard)
animate() termine
```

---

## Le paramètre `timestamp`

Le navigateur passe automatiquement un `timestamp` à la fonction callback :
```javascript
const animate = (timestamp) => {
  console.log(timestamp) // 1234.567, 1250.891, 1267.123...
}
```

**`timestamp` = temps en millisecondes depuis le chargement de la page**

### Pourquoi c'est important : le delta time

Pour avoir une animation à **vitesse constante** (indépendante du framerate), on calcule le **temps écoulé** entre deux frames :
```javascript
let lastTime = null

const animate = (timestamp) => {
  if (!lastTime) lastTime = timestamp
  
  // Delta = temps écoulé en secondes
  const delta = (timestamp - lastTime) / 1000
  lastTime = timestamp
  
  // Animation proportionnelle au temps réel
  angle += (Math.PI / 4) * delta  // π/4 rad/sec, peu importe le framerate
  
  requestAnimationFrame(animate)
}
```

**Sans delta :** l'animation irait 2× plus vite sur un écran 120Hz que sur un écran 60Hz  
**Avec delta :** vitesse constante quel que soit le framerate ✅

---

## Pourquoi pas `setInterval` ?

### ❌ Problèmes de `setInterval`
```javascript
setInterval(() => {
  animate()
}, 16) // Essaie de faire 60fps
```

1. **Pas synchronisé avec l'écran** → animations saccadées (screen tearing)
2. **Continue en arrière-plan** → gaspillage CPU/batterie quand l'onglet est caché
3. **Pas adaptatif** → lag s'accumule si l'ordi est surchargé

### ✅ Avantages de RAF

- Synchronisé avec le refresh de l'écran → fluide
- S'arrête automatiquement si l'onglet n'est pas visible
- Le navigateur optimise (skip frames si nécessaire)

---

## Arrêter l'animation
```javascript
// Stocker l'ID retourné par RAF
const animationId = requestAnimationFrame(animate)

// Plus tard, annuler
cancelAnimationFrame(animationId)
```

---

## Utilisation dans React
```jsx
import { useEffect, useRef, useState } from 'react'

function AnimatedComponent() {
  const [angle, setAngle] = useState(0)
  const animationRef = useRef(null)
  const lastTimeRef = useRef(null)

  useEffect(() => {
    const animate = (timestamp) => {
      if (!lastTimeRef.current) lastTimeRef.current = timestamp
      
      const delta = (timestamp - lastTimeRef.current) / 1000
      lastTimeRef.current = timestamp
      
      setAngle(prev => prev + (Math.PI / 4) * delta)
      
      animationRef.current = requestAnimationFrame(animate)
    }
    
    animationRef.current = requestAnimationFrame(animate)
    
    // Cleanup : arrête l'animation quand le composant unmount
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current)
      }
    }
  }, [])

  return <div>Angle: {angle.toFixed(2)}</div>
}
```

### Pourquoi `useRef` ?

- `animationRef` : stocke l'ID pour pouvoir cancel plus tard
- `lastTimeRef` : stocke le timestamp précédent (persiste entre re-renders)

---

## Schéma mental
```
┌─────────────────────┐
│ requestAnimationFrame│  Contrôle QUAND (rythme)
└──────────┬──────────┘
           │ appelle toutes les ~16ms
           ▼
┌─────────────────────┐
│   animate(timestamp)│
└──────────┬──────────┘
           │ calcule delta
           ▼
┌─────────────────────┐
│  delta = temps écoulé│  Contrôle COMBIEN (mouvement)
└──────────┬──────────┘
           │ delta × vitesse
           ▼
┌─────────────────────┐
│  Mise à jour géométrie│  (angle, position, etc.)
└─────────────────────┘
```

---

## Cas d'usage

### ✅ Utilisé pour :
- Animations visuelles fluides
- Jeux vidéo web
- Visualisations de données animées
- Canvas 2D/3D (Three.js, JSXGraph, etc.)

### ❌ Pas utilisé pour :
- Tâches répétitives non-visuelles → `setInterval`
- Délais uniques → `setTimeout`
- Polling API → `setInterval`

---

## Points clés à retenir

1. **RAF = API navigateur native** (pas liée à une librairie)
2. **Synchronisé avec l'écran** → animations fluides
3. **Récursion asynchrone** → pas de stack overflow
4. **`timestamp`** fourni automatiquement par le navigateur
5. **`delta = temps écoulé`** → vitesse constante indépendante du framerate
6. **Toujours préférer RAF à `setInterval`** pour les animations visuelles

---

## Ressources

- [MDN: requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
- [JavaScript.info: Animation](https://javascript.info/js-animation)

---

## Application pratique

J'ai utilisé RAF dans mon projet paul-craft-react pour animer le cercle trigonométrique :
- Point qui tourne à vitesse constante
- Synchronisation avec JSXGraph
- Contrôles React (play/pause) qui démarrent/arrêtent l'animation